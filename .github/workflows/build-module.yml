name: Build Magisk Module

on:
  workflow_dispatch:
    inputs:
      include_singbox:
        description: 'Include agent core binary in zip'
        type: choice
        options:
          - 'true'
          - 'false'
        default: 'false'
      architecture:
        description: "Target Android architecture"
        type: choice
        options:
          - arm64-v8a
          - armeabi-v7a
          - x86
          - x86_64
        default: "arm64-v8a"
      bin_name:
        description: "The name of the binary file to look for in releases."
        type: string
        default: "sing-box"
      bin_repo:
        description: "The agent core repository (owner/repo)"
        type: string
        default: "SagerNet/sing-box"
      release_tag:
        description: "The agent core release tag (e.g., v1.9.0-beta.11). Leave empty for latest."
        required: false
        type: string


jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download agent core binary
        if: ${{ inputs.include_singbox == 'true' }}
        id: download-binary
        shell: bash
        run: |
          set -e
          
          ARCH="${{ inputs.architecture }}"
          REPO="${{ inputs.bin_repo }}"
          TAG="${{ inputs.release_tag }}"
          BIN_NAME="${{ inputs.bin_name }}"
          
          # Determine GitHub API URL
          if [[ -z "$TAG" ]]; then
            API_URL="https://api.github.com/repos/$REPO/releases/latest"
            echo "Fetching latest release from $REPO"
          else
            API_URL="https://api.github.com/repos/$REPO/releases/tags/$TAG"
            echo "Fetching release $TAG from $REPO"
          fi
          
          # Get release info
          RELEASE_JSON=$(curl -sL -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "$API_URL")
          
          # Define architecture patterns
          declare -A patterns
          patterns["arm64-v8a"]="android.*(arm64|aarch64);linux.*(arm64|aarch64|armv8)"
          patterns["armeabi-v7a"]="android.*(armv7|arm-v7);linux.*(armv7|arm-v7)"
          patterns["x86"]="android.*(x86);linux.*(x86|i386)"
          patterns["x86_64"]="android.*(x86_64|amd64);linux.*(x86_64|amd64)"
          
          # Find asset URL
          ASSET_URL=""
          IFS=';' read -ra arch_patterns <<< "${patterns[$ARCH]}"
          for pattern in "${arch_patterns[@]}"; do
            ASSET_URL=$(echo "$RELEASE_JSON" | jq -r ".assets[] | select(.name | test(\"$pattern\"; \"i\")) | .browser_download_url" | head -n1)
            if [[ -n "$ASSET_URL" ]]; then
              echo "Found matching asset for pattern '$pattern': $ASSET_URL"
              break
            fi
          done
          
          if [[ -z "$ASSET_URL" ]]; then
            echo "No specific architecture match found, trying to find a generic binary."
            ASSET_URL=$(echo "$RELEASE_JSON" | jq -r ".assets[] | select(.name | test(\"$BIN_NAME\"; \"i\")) | .browser_download_url" | head -n1)
          fi
          
          if [[ -z "$ASSET_URL" ]]; then
            echo "::error::Could not find a suitable binary for architecture $ARCH."
            exit 1
          fi
          
          # Download and extract
          TMPDIR=$(mktemp -d)
          FNAME="$TMPDIR/asset"
          
          echo "Downloading from $ASSET_URL..."
          curl -L -o "$FNAME" "$ASSET_URL"
          
          echo "Downloaded file type:"
          file "$FNAME"

          BPATH=""
          MIME_TYPE=$(file --mime-type -b "$FNAME")
          echo "Detected MIME type: $MIME_TYPE"

          if [[ "$MIME_TYPE" == "application/zip" ]]; then
            unzip -o "$FNAME" -d "$TMPDIR"
            BPATH=$(find "$TMPDIR" -type f -iname "$BIN_NAME" | head -n1)
          elif [[ "$MIME_TYPE" == "application/gzip" || "$MIME_TYPE" == "application/x-gzip" ]]; then
            tar -xzf "$FNAME" -C "$TMPDIR"
            BPATH=$(find "$TMPDIR" -type f -iname "$BIN_NAME" | head -n1)
          else
            # Assume it's a raw binary
            mv "$FNAME" "$TMPDIR/$BIN_NAME"
            BPATH="$TMPDIR/$BIN_NAME"
          fi
          
          if [[ -z "$BPATH" ]]; then
            echo "::error::Could not find '$BIN_NAME' in the downloaded asset."
            exit 1
          fi
          
          echo "Binary found at: $BPATH"
          mv "$BPATH" "./$BIN_NAME"
          chmod +x "./$BIN_NAME"
          
          echo "Successfully placed binary at ./$BIN_NAME"
          rm -rf "$TMPDIR"

      - name: Set script permissions
        run: |
          chmod 755 ./*.sh

      - name: Package module
        id: package
        run: |
          # Create a directory to hold the module files
          mkdir -p module_package

          # Copy all files into the package directory, excluding unwanted files/dirs
          rsync -a --exclude='.git' --exclude='.github' --exclude='*.zip' --exclude='module_package' ./ module_package/

          # The upload-artifact action will zip this directory.
          echo "package_path=module_package" >> $GITHUB_OUTPUT

          echo "short_sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Upload module artifact
        uses: actions/upload-artifact@v4
        with:
          name: Seisa-Module-${{ steps.package.outputs.short_sha }}
          path: ${{ steps.package.outputs.package_path }}